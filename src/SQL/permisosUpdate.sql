Insert INTO public.rolls (id, level, read, write, delete, invite, configure) VALUES ('18244be7-6f88-48ff-8bf3-911f1d712618', 'Lector', true, false, false, false, false);
ALTER TABLE public.organization_invitations ADD COLUMN level_id uuid REFERENCES public.rolls(id) ON DELETE SET NULL;
DROP FUNCTION public.get_user_organizations;
CREATE OR REPLACE FUNCTION public.get_user_organizations(p_user_id uuid, p_name text DEFAULT NULL::text, p_page integer DEFAULT 1, p_page_size integer DEFAULT 10)
 RETURNS TABLE(
  id uuid, 
  name character varying, 
  description text, 
  slug character varying, 
  open boolean, 
  created_at timestamp with time zone, 
  user_id uuid, 
  is_creator boolean, 
  is_member boolean,
  levelTitle varchar,
  read boolean,
  write boolean,
  delete boolean,
  invite boolean,
  configure boolean,
  total_count bigint
  )
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_start INTEGER;
  v_end INTEGER;
  v_total_count BIGINT;
BEGIN
  -- Calculate pagination
  v_start := (p_page - 1) * p_page_size;
  
  -- Get the total count first
  SELECT COUNT(DISTINCT o.id) INTO v_total_count
  FROM organizations o
  LEFT JOIN organizations_users ou ON o.id = ou.organization_id
  WHERE o.open = true
    AND (o.user_id = p_user_id OR ou.user_id = p_user_id)
    AND (p_name IS NULL OR o.name ILIKE '%' || p_name || '%');
  
  -- Return the organizations with pagination
  RETURN QUERY
  WITH user_orgs AS (
    SELECT DISTINCT ON (o.id)
      o.id,
      o.name,
      o.description,
      o.slug,
      o.open,
      o.created_at,
      o.user_id,
      (o.user_id = p_user_id) AS is_creator,
      (ou.user_id IS NOT NULL) AS is_member,
      roll.level,
      roll.read,
      roll.write,
      roll.delete,
      roll.invite,
      roll.configure
    FROM organizations o
    LEFT JOIN organizations_users ou ON o.id = ou.organization_id AND ou.user_id = p_user_id
    LEFT JOIN rolls roll ON roll.id = ou.roll_id
    WHERE o.open = true
      AND (o.user_id = p_user_id OR ou.user_id = p_user_id)
      AND (p_name IS NULL OR o.name ILIKE '%' || p_name || '%')
    ORDER BY o.id, o.created_at DESC
  )
  SELECT 
    uo.*,
    v_total_count AS total_count
  FROM user_orgs uo
  ORDER BY uo.created_at DESC
  LIMIT p_page_size
  OFFSET v_start;
END;
$function$


---

INSERT INTO public.organizations (id, name, description, slug, open, user_id) VALUES ('f47ac10b-58cc-4372-a567-0e02b2c3d479', 'Empieza por Aquí', 'Este grupo de trabajo ofrece ayuda sobre la app', 'tutorial', true, '3e5e79b4-a248-409f-8b07-c2fbd4d11991');


CREATE OR REPLACE FUNCTION spreadTutorial()
RETURNS void AS $$
BEGIN
    -- Inserta nuevos registros en la tabla 'organizations_users'.
    -- La inserción se realiza para cada usuario que aún no pertenece a la organización especificada.
    INSERT INTO public.organizations_users (user_id, organization_id, roll_id)
    SELECT
        u.id,                                     -- El ID del usuario a agregar
        'f47ac10b-58cc-4372-a567-0e02b2c3d479', -- El ID de la organización de destino
        '18244be7-6f88-48ff-8bf3-911f1d712618'  -- El ID del rol que se asignará
    FROM
        auth.users u
    WHERE
        -- La cláusula 'NOT EXISTS' se asegura de que solo seleccionemos usuarios
        -- que no tengan ya un registro en 'organizations_users' para esta organización.
        NOT EXISTS (
            SELECT 1
            FROM public.organizations_users ou
            WHERE ou.user_id = u.id
            AND ou.organization_id = 'f47ac10b-58cc-4372-a567-0e02b2c3d479'
        );
END;
$$ LANGUAGE plpgsql;

SELECT spreadTutorial();


-- para nuevos usuarios

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER -- Esto permite que la función se ejecute con permisos elevados.
AS $$
BEGIN
  -- Insertar un nuevo registro en la tabla organizations_users.
  -- NEW es una variable especial que contiene el nuevo registro insertado en auth.users.
  INSERT INTO public.organizations_users (user_id, organization_id, roll_id)
  VALUES (
    NEW.id,
    'f47ac10b-58cc-4372-a567-0e02b2c3d479',
    '18244be7-6f88-48ff-8bf3-911f1d712618'
  );

  RETURN NEW; -- La función debe retornar NEW para triggers AFTER INSERT.
END;
$$;

-- Paso 2: Crear el trigger para la tabla auth.users.
-- Este trigger llama a la función `handle_new_user` cada vez que se inserta un nuevo registro.
-- Se activa "AFTER INSERT" (después de la inserción) para cada "ROW" (fila).
CREATE OR REPLACE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();

--
create table public.errors_log (
  id bigint generated by default as identity not null,
  message text not null,
  stack text null,
  timestamp date null,
  constraint errors_log_pkey primary key (id)
);



--

ALTER TABLE auth.users DISABLE TRIGGER on_auth_user_created;

ALTER TABLE auth.users ENABLE TRIGGER on_auth_user_created;